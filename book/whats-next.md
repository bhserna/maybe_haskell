At the start of this book, I said my intention was not to teach you Haskell.
Instead, my goal was to give you a sense of writing realistic code that takes
advantage of an uncommon feature found in the Haskell language. I wanted to
strike a balance between short sound-bites without much depth and the large
investment of time required to become proficient in the language.

The central theme, the `Maybe` type, is an example of Haskell's principled
stance resulting in tangible benefit for programmers. The frustration caused by
Tony Hoare's self-proclaimed ["billion-dollar mistake"][mistake] is something
I'll gladly live without. This same principled stance has lead to many similar
outcomes in the Haskell language. From monadic I/O to advanced concurrency
primitives, Haskell is full of constructs only made possible through slow and
thoughtful language design. My hope is that by seeing--and really
understanding--the relatively small example that is `Maybe`, you'll be motivated
to explore the language further.

[mistake]: http://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions

If you are so inclined, there are many resources online for getting up and
running, what to read, etc. I mentioned Chris Allan's [learning
path][learnhaskell] already. There's also [Haskell in 5 steps][steps]. I'm a
huge fan of [Learn You a Haskell for Great Good!][lyah] and [Real World
Haskell][rwh] if you're looking for books. If you prefer an exercise-based
approach, we have a [Haskell Fundamentals][trail] trail on Upcase. Finally,
don't be afraid to read academic papers. They are dense sources of very good
information.

[steps]: https://wiki.haskell.org/Haskell_in_5_steps
[lyah]: http://learnyouahaskell.com/
[rwh]: http://book.realworldhaskell.org/
[trail]: https://upcase.com/haskell-fundamentals
